////////////////////////////////////////////////////////////////////////
//
// DataElement.java
//
// This file was generated by MapForce 2011.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.text.edi;

import com.altova.text.ITextNode;
import com.altova.text.edi.Scanner.State;

import java.io.IOException;

public class DataElement extends StructureItem {
	DataTypeValidator mValidator;

	public DataElement (String name, DataTypeValidator validator) {
		super(name, ITextNode.DataElement);
		mValidator = validator;
	}

	public boolean read (Parser.Context context) {
		State beforeState = context.getScanner().getCurrentState();
		if ( context.getParser().getEDIKind() == EDISettings.EDIFixed )
		{
			Scanner scanner = context.getScanner();
			StringBuffer sBuffer = new StringBuffer();
			while( sBuffer.length() < mValidator.getMaxLength() && !scanner.isAtEnd() )
				sBuffer.append( scanner.rawConsumeChar() );

			mValidator.makeValidOnRead( sBuffer, context, beforeState);
			if ( sBuffer.length() == 0)
				return false; //data element is absent

			context.getGenerator().insertElement (context.getParticle().getName(), sBuffer.toString(), mNodeClass);
			return true;
		}

        //MSH-2 in HL7 MODE also needs special treatment
		if( context.getParticle().getName().equals( "MSH-2") &&
				context.getParser().getEDIKind() == EDISettings.EDIHL7)
		{
			Scanner scanner = context.getScanner();
			String s = new String();
			char c = scanner.rawConsumeChar();
			scanner.mServiceChars.setComponentSeparator( c);
			s += c;
			s += c = scanner.rawConsumeChar();
			scanner.mServiceChars.setRepetitionSeparator( c);
			if( scanner.getCurrentChar() != scanner.mServiceChars.getComponentSeparator())
			{
				s += c = scanner.rawConsumeChar();
				scanner.mServiceChars.setReleaseCharacter( c);
			}
			if( scanner.getCurrentChar() != scanner.mServiceChars.getComponentSeparator())
			{
				s += c = scanner.rawConsumeChar();
				scanner.mServiceChars.setSubComponentSeparator( c);
			}
			context.getGenerator().insertElement (context.getParticle().getName(), s, mNodeClass);
			return true;
		}

		StringBuffer s = context.getScanner().consumeString(ServiceChars.ComponentSeparator, true);
		if ( s.length() == 0 )
			return false;  // data element is absent

		if (!mValidator.makeValidOnRead (s, context, beforeState))
			return false;

		if( context.getParser().getEDIKind() == EDISettings.EDIX12 )
		{
			if( context.getParticle().getName().equals( "F447") && context.getCurrentSegmentName().equals("LS") )
				context.getParser().setF447( new String( s) );
		}
			
		if (!mValidator.hasValue( s.toString()))
			context.handleError(
				Parser.ErrorType.CodelistValueWrong,
				ErrorMessages.GetInvalidCodeListValueMessage(s.toString(), mValidator.getCodeListValues()),
				new ErrorPosition( beforeState ),
				s.toString()
			);

		String sError = context.getValidator().validate( context.getParticle().getName(), s.toString());
		if( sError.length() > 0)
			context.handleError( 
				Parser.ErrorType.SemanticWrong,
				sError,
				new ErrorPosition( beforeState ),
				s.toString()
			);

		context.getGenerator().insertElement (context.getParticle().getName(), s.toString(), mNodeClass);

		return true;
	}

	public void write (Writer writer, ITextNode node) throws IOException {

		if (writer.getEDIKind() == EDISettings.EDIFixed)
		{
			StringBuffer sBuffer = new StringBuffer(node.getValue());
			mValidator.makeValidOnWrite( sBuffer, node, writer, false);
			writer.write( sBuffer.toString() );
			return;
		}

		StringBuffer sbvalue = new StringBuffer(node.getValue());
		boolean escapeString = true;
        if (node.getName().equals("MSH-2") && writer.getEDIKind() == EDISettings.EDIHL7)
        {
            sbvalue = new StringBuffer();
            sbvalue.append( writer.getServiceChars().getComponentSeparator());
            sbvalue.append( writer.getServiceChars().getRepetitionSeparator());
            sbvalue.append( writer.getServiceChars().getReleaseCharacter());
            sbvalue.append( writer.getServiceChars().getSubComponentSeparator());
            //don't escape separators
			escapeString = false;
        }

		if (!mValidator.makeValidOnWrite (sbvalue, node, writer, escapeString))
        	return;

		//codelist validate
		String sValue = sbvalue.toString();
		if (!mValidator.hasValue( sValue))
			writer.handleError( node, Parser.ErrorType.CodelistValueWrong, ErrorMessages.GetInvalidCodeListValueMessage(sValue, mValidator.getCodeListValues()) );

		//edi validate
		String sError = writer.getValidator().validate( node.getName(), sValue);
		if( sError.length() > 0)
			writer.handleError( node, Parser.ErrorType.SemanticWrong, sError);


		writer.write (sValue);
	}
}
